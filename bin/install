#!/usr/bin/env fish
# Oh My Fish installer. See `install --help` for usage.

# Set environment options.
set -q OMF_REPO_URI;    or set OMF_REPO_URI "https://github.com/oh-my-fish/oh-my-fish"
set -q OMF_REPO_BRANCH; or set OMF_REPO_BRANCH "master"


function main
  # Set default settings
  set -q XDG_DATA_HOME
    and set -g OMF_PATH "$XDG_DATA_HOME/omf"
    or set -g OMF_PATH "$HOME/.local/share/omf"

  set -q XDG_CONFIG_HOME
    and set -g CONFIG_PATH "$XDG_CONFIG_HOME"
    or set -g CONFIG_PATH "$HOME/.config"

  set -g OMF_CONFIG "$CONFIG_PATH/omf"
  set -g FISH_CONFIG "$CONFIG_PATH/fish"

  # Ensure repository URL ends with .git
  set OMF_REPO_URI (echo $OMF_REPO_URI | command sed 's/\.git//').git

  # Parse command args
  while set -q argv[1]
    switch "$argv[1]"
      case --help -h '/?'
        echo "Usage: install [options]
  Install Oh My Fish

Options:
  --config=<path>         Put config in a specific path (default is $OMF_CONFIG).
  --help, -h              Show this help message.
  --noninteractive        Disable interactive questions (assume no, use with --yes to assume yes).
  --offline[=<path>]      Offline install, optionally specifying a tar or directory to use.
  --path=<path>           Use a specific install path (default is $OMF_PATH).
  --uninstall             Uninstall existing installation instead of installing.
  --yes, -y               Assume yes for interactive questions.
"
        return 0

      case '--config=*'
        echo "$argv[1]" | command cut -d= -f2 | read -g OMF_CONFIG

      case --noninteractive
        set -g NONINTERACTIVE

      case --offline
        set -g OFFLINE

      case '--offline=*'
        set -g OFFLINE
        echo "$argv[1]" | command cut -d= -f2 | read -g OFFLINE_PATH

      case '--path=*'
        echo "$argv[1]" | command cut -d= -f2 | read -g OMF_PATH

      case --uninstall
        set -g UNINSTALL

      case --yes -y
        set -g ASSUME_YES

      case '*'
        abort "Unrecognized option '$argv[1]'"
    end
    set -e argv[1]
  end

  # Ensure the environment meets all of the requirements.
  assert_cmds
  assert_fish_version_compatible
  assert_git_version_compatible
  assert_interactive

  # If the user wants to uninstall, jump to uninstallation and exit.
  if set -q UNINSTALL
    uninstall_omf
    return
  end

  # Check if OMF is already installed.
  if test -d "$OMF_PATH"
    say "Existing installation detected at $OMF_PATH"

    confirm_yes "Would you like to remove the existing installation?"
    uninstall_omf
  end

  # Begin the install process.
  install_omf
    and create_config
    or abort "Oh My Fish installation failed.\n\nIf you think that it's a bug, please open an\nissue with the complete installation log here:\n\nhttp://github.com/oh-my-fish/oh-my-fish/issues"

  # We made it!
  say "Installation successful!"

  # Open a brand new shell if we are in interactive mode.
  set -q NONINTERACTIVE
    or exec fish < /dev/tty

  return 0
end


# Installs Oh My Fish.
function install_omf
  say "Installing Oh My Fish to $OMF_PATH..."

  # Prepare paths
  command mkdir -p (dirname "$OMF_PATH")

  # Install step
  if set -q OFFLINE
    install_offline
  else
    install_from_github
  end
end


# Downloads and installs the framework from GitHub.
function install_from_github
  say "Cloning $OMF_REPO_BRANCH from $OMF_REPO_URI..."

  if not command git clone -q --depth 1 -b $OMF_REPO_BRANCH $OMF_REPO_URI "$OMF_PATH"
    abort "Error cloning repository!"
  end

  set_git_remotes
end


# Install the framework from an offline copy of the source.
function install_offline
  # Prepare the path
  if set -q OFFLINE_PATH
    # Make sure the given path exists
    if not test -e "$OFFLINE_PATH"
      abort "Local installation does not exist"
    end
  else
    # If no path was set, check if the installer is running inside of the source directory.
    set -l path (dirname (dirname (status -f)))

    if dir_is_install "$path"
      set OFFLINE_PATH "$path"
    # Try using the current working directory as the source.
    else if dir_is_install "$PWD"
      set OFFLINE_PATH "$PWD"
    else
      # We tried our best.
      abort "Could not find local installation"
    end
  end

  # Check if the path is some sort of tar.
  if test -f "$OFFLINE_PATH"
    say "Offline path is a file, assuming tar archive..."

    command tar -xf "$OFFLINE_PATH" -C "$OMF_PATH"
      or abort "Could not extract tar file $OFFLINE_PATH"

    return
  end

  # At this point, path must be a directory.
  if not test -d "$OFFLINE_PATH"
    abort "$OFFLINE_PATH is not a directory"
  end

  # Copy the source into the install location.
  command cp -r "$OFFLINE_PATH" "$OMF_PATH"
    or abort "Failed to copy source!"

  # Set up Git remotes only if the offline install is a Git repository.
  test -d "$OMF_PATH/.git"
    and set_git_remotes

  return 0
end


# Set upstream remotes on the framework Git repository.
function set_git_remotes
  set git_upstream (command git --git-dir "$OMF_PATH/.git" --work-tree "$OMF_PATH" config remote.upstream.url)

  if test -z "$git_upstream"
    command git --git-dir "$OMF_PATH/.git" --work-tree "$OMF_PATH" remote add upstream $OMF_REPO_URI
  else
    command git --git-dir "$OMF_PATH/.git" --work-tree "$OMF_PATH" remote set-url upstream $OMF_REPO_URI
  end
end


# Uninstalls an existing OMF installation.
function uninstall_omf
  dir_is_install "$OMF_PATH"
    or abort "No installation detected at $OMF_PATH"

  say "Warning: This will uninstall Oh My Fish and all plugins and themes installed in $OMF_PATH. Your configuration will not be modified. You will need to remove any Oh My Fish startup code from $FISH_CONFIG/config.fish."

  confirm_yes "Are you sure you want to continue?"
  say "Uninstalling from $OMF_PATH..."

  command rm -rf "$OMF_PATH/.git"
    and command rm -r "$OMF_PATH"
    and say "Uninstall complete"
    or abort "Uninstall failed"
end


# Creates user configuration files.
function create_config
  set fish_config_file "$FISH_CONFIG/config.fish"

  backup_file "$fish_config_file"
    or command mkdir -p "$FISH_CONFIG"

  backup_file "$FISH_CONFIG/functions/fish_prompt.fish"

  say "Adding startup code to fish config file..."

  set template "templates/config.fish"
  set replacements "s|{{OMF_CONFIG}}|$OMF_CONFIG|"

  if test "$OMF_CONFIG" != "$CONFIG_PATH/omf"
    set replacements "$replacements;s|#set|set|"
  end

  sed "$replacements" "$OMF_PATH/$template" > "$fish_config_file"

  say "Building Oh My Fish configuration..."

  if not test -d "$OMF_CONFIG"
    command mkdir -p "$OMF_CONFIG"
  end

  test -f "$OMF_CONFIG/bundle"; or echo "theme default" > "$OMF_CONFIG/bundle"
  test -f "$OMF_CONFIG/theme";  or echo "default" > "$OMF_CONFIG/theme"

  # Install plugins
  fish -c "omf install"
end


# Makes a backup of a given file.
function backup_file -a file_path
  test -e "$file_path"; or return 1

  set -l path (dirname $file_path)
  set -l file (basename $file_path)
  set -l name (echo $file | command cut -d. -f1)

  set -l timestamp (date +%s)
  set -l backup_file "$path/$name.$timestamp.copy"

  say "Existent $file found at $path"
  say "â†³ Moving to $backup_file"

  if not mv "$file_path" $backup_file 2>/dev/null
    abort "Could not backup $file_path"
  end

  return 0
end


# Checks if a path looks like an OMF install.
function dir_is_install -a path
  test -n "$path"
    and test -d "$path"
    and test -d "$path/pkg/omf"
end


# Assert that all tools we need are available.
function assert_cmds
  set cmds basename cp cut date dirname fish fold git mkdir mv sed sort tar

  for cmd in $cmds
    type -q $cmd
      or abort "Command '$cmd' not found"
  end
end


# Assert that the minimum required version of Fish is installed.
function assert_fish_version_compatible
  set -q FISH_VERSION; or set -l FISH_VERSION $version

  if not compare_version_compatible 2.2.0 $FISH_VERSION
    abort "Fish version 2.2.0 or greater required; you have $FISH_VERSION"
  end
end


# Assert that the minimum required version of Git is installed.
function assert_git_version_compatible
  set -l git_version (command git --version | command cut -d' ' -f3)

  if not compare_version_compatible 1.9.5 $git_version
    abort "Git version 1.9.5 or greater required; you have $git_version"
  end
end


# Tests if the right-hand side version is equal to or greater than the left-hand side version.
function compare_version_compatible -a lhs rhs
  test "$lhs" = (printf "$lhs\n$rhs\n" | command sort -t '.' -k 1,1 -k 2,2 -k 3,3 -k 4,4 -g)[1]
end


# Ensures the keyboard is readable if in interactive mode.
function assert_interactive
  set -q NONINTERACTIVE
    and return

  test -c /dev/tty -a -r /dev/tty
    and echo -n > /dev/tty ^ /dev/null
    or abort "Running interactively, but can't read from tty (try running with --noninteractive)"
end


# Print a message to the user.
function say -a message
  printf "$message\n" | command fold -s -w 80
end


# Aborts the installer and displays an error.
function abort -a message
  if test -n "$message"
    printf "%sInstall aborted: $message%s\n" (set_color red ^ /dev/null) (set_color normal ^ /dev/null) >&2
  else
    printf "%sInstall aborted%s\n" (set_color red ^ /dev/null) (set_color normal ^ /dev/null) >&2
  end

  exit 2
end


# Asks the user for confirmation.
function confirm -a message
  # Return true if we assume yes for all questions.
  set -q ASSUME_YES
    and return 0

  # Return false if we can't ask the question.
  set -q NONINTERACTIVE
    and return 1

  printf "%s$message (y/n): %s" (set_color yellow ^ /dev/null) (set_color normal ^ /dev/null)
  read -l answer < /dev/tty
    or abort "Failed to read from tty"

  not test "$answer" != y -a "$answer" != Y -a "$answer" != yes
end


# Asks the user for a confirmation or aborts.
function confirm_yes -a message
  confirm "$message"
    or abort
end


main $argv
